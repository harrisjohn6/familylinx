var nodes =  //
            const clusters = @json($clusters);
            var container = document.getElementById("familyTree");
            var data = {
                nodes: nodes,
                edges: edges,
            };
            var options = {
                nodes: {
                    shape: "circularImage", // Display images in a circle
                    size: 50, // Adjust image size
                },
                layout: {
                    hierarchical: false,
                    improvedLayout: true,
                },
                physics: {
                    enabled: true,
                    solver: "forceAtlas2Based",
                    hierarchicalRepulsion: {
                        nodeDistance: 1000, // Increased from your previous value
                        centralGravity: 0.5, // Increased from your previous value
                    },
                },
                edges: {
                    dashes: true,
                    physics: false,
                    hidden: false,
                    length: 1000,
                },
                clickToUse: false,
            };
            var network = new vis.Network(container, data, options);
            network.on("stabilized", function() {
                clusters.forEach((cluster) => {
                    // Iterate over clusters
                    groupNodes(cluster.id, cluster.parentNodes, cluster.childNode);

                    let rootNode = nodes.get(rootNodeId);
                    if (rootNode) {
                        let networkCanvas = network.getPositions(); // Get network extents
                        rootNode.x = networkCanvas[rootNode.id].x; // Keep x-position from physics
                        rootNode.y = networkCanvas[rootNode.id].y; // Keep y-position from physics

                        network.moveNode(
                            rootNodeId,
                            networkCanvas[rootNodeId].x,
                            0.5 * networkCanvas[rootNodeId].y
                        );
                    }
                });
            });

            function groupNodes(clusterId, nodeIds, childNodeId) {
                let minX = Infinity,
                    maxX = -Infinity,
                    minY = Infinity,
                    maxY = -Infinity;

                const clusterDiv = document.createElement("div");
                const childNode = nodes.get(childNodeId);
                const labelText = childNode.label || "Child";
                const allClusters = document.getElementsByClassName("cluster-overlay");
                const clusterWidth = maxX - minX;
                const clusterHeight = maxY - minY;
                const clusterCenterX = minX + clusterWidth / 2;

                const label = document.createElement("div");
                label.textContent = labelText;
                label.classList.add("cluster-label");
                clusterDiv.appendChild(label);

                clusterDiv.id = `cluster-${clusterId}`;
                clusterDiv.classList.add("cluster-overlay"); // Add a CSS class for styling
                document.getElementById("familyTree").appendChild(clusterDiv); // Insert into the DOM


                nodeIds.forEach((nodeId) => {
                    const node = nodes.get(nodeId);
                    if (node !== null && node.x !== undefined && node.y !== undefined) {
                        // Check for valid node and positions
                        minX = Math.min(minX, node.x);
                        maxX = Math.max(maxX, node.x);
                        minY = Math.min(minY, node.y);
                        maxY = Math.max(maxY, node.y);
                    }
                });
                const rootNode = nodes.get(rootNodeId);

                if (!rootNode) {
                    return;
                } // Safety check


                for (let i = 0; i < allClusters.length; i++) {
                    if (allClusters[i].id === `cluster-${clusterId}`) {
                        continue; // Skip the current cluster
                    }

                    if (clustersOverlap(allClusters[i], clusterDiv)) {
                        verticalOffset -= clusterHeight * 1.5; // Adjust factor as needed
                    }
                }

                let verticalOffset = rootNode.y - clusterHeight * 3; // Initial offset
                clusterDiv.style.left = `${clusterCenterX - clusterWidth / 2}px`;
                clusterDiv.style.top = `${verticalOffset}px`;
                clusterDiv.style.width = `${clusterWidth}px`;
                clusterDiv.style.height = `${clusterHeight}px`;


            }

            network.on("click", function(event) {
                if (event.nodes.length > 0) {

                    const clickedNodeId = event.nodes[0];
                    showMenu(event.pointer.DOM, clickedNodeId); // Show the menu, passing the mouse position
                }
            });

            function clustersOverlap(cluster1, cluster2) {
                const rect1 = cluster1.getBoundingClientRect();
                const rect2 = cluster2.getBoundingClientRect();

                return !(
                    rect1.right < rect2.left ||
                    rect1.left > rect2.right ||
                    rect1.bottom < rect2.top ||
                    rect1.top > rect2.bottom
                );
            }

            function showMenu(position, clickedNodeId) {

                const contextMenu = document.getElementById("contextMenu");
                const clickedNode = nodes.get(clickedNodeId);
                const nodeName = clickedNode.label || "Untitled Node"; // Or another property if you store the name differently
                const addFamilyButton = document.getElementById("addFamilyButton"); // Assuming you add an ID to the button
                const inviteFamilyForm = document.getElementById("inviteFamilyForm");
                const parentNodeIdInput = document.getElementById("parentNodeId");

                inviteFamilyForm.addEventListener("submit", function(event) {
                    event.preventDefault(); // Prevent default form submission

                    const formData = new FormData(inviteFamilyForm);

                    sendAddFamilyRequest(formData);
                });

                setTimeout(() => {
                    contextMenu.style.display = "block";
                }, 100);

                contextMenu.style.opacity = "1";
                contextMenu.style.position = "absolute";
                contextMenu.style.left = `${position.x}px`;
                contextMenu.style.top = `${position.y}px`;
                contextMenu.style.zIndex = "9999"; // Ensure it's on top

                contextMenu.innerHTML = `
        <p>${nodeName}</p>
        <form id="inviteFamilyForm">
            <input type="hidden" name="parentNodeId" id="parentNodeId">
            <input type="email" name="inviteEmail" placeholder="Email" required>
            <button type="submit">Add Family</button>
        </form>
        <button id="editProfileButton">Edit Profile</button>
    `;

                parentNodeIdInput.value = clickedNodeId;

                inviteFamilyForm.addEventListener("submit", function(event) {
                    // ... the rest of your existing form submission logic ...
                });
                addFamilyButton.addEventListener("click", function() {
                    sendAddFamilyRequest(clickedNodeId);
                });
            }
            document.addEventListener("click", function(event) {
                const contextMenu = document.getElementById("contextMenu");
                if (!contextMenu.contains(event.target)) {
                    contextMenu.style.display = "none";
                }
            });

            function sendAddFamilyRequest(clickedNodeId) {
                const data = {
                    // ... Collect additional data needed for the invite here (if any)
                    parentNodeId: clickedNodeId,
                    body: formData,
                };

                fetch("/invite-family", {
                        // Adjust the route if needed
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRF-TOKEN": document
                                .querySelector('meta[name="csrf-token"]')
                                .getAttribute("content"), // For CSRF protection
                        },
                        body: JSON.stringify(data),
                    })
                    .then((response) => {
                        if (response.ok) {} else {
                            // Handle error
                            console.error("Invite failed:", response);
                        }
                    })
                    .catch((error) => {
                        console.error("Error:", error);
                    });
            }
